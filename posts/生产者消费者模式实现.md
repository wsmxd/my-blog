---
title: "生产者消费者模式实现"
date: "2025-11-2"
description: "使用C#实现经典的生产者消费者模式，结合信号量和读写锁，确保线程安全和高效的生产消费流程。"
tags: ["C#", "多线程", "操作系统"]
cover: "/images/shizuku.jpg"
category: "professional"
---

# 生产者消费者模式实现

## 简介
生产者消费者模式是多线程编程中的经典模式，用于解决生产者和消费者之间的同步问题。本实现使用C#展示了基于信号量和读写锁的生产者消费者模式。

## 代码实现
```csharp
using System;
using System.Collections.Generic;
using System.Threading;

class Program {
    private static Queue<int> buffer = new();
    private const int Capacity = 5;
    
    private static SemaphoreSlim empty = new(Capacity, Capacity); // 空位信号量
    private static SemaphoreSlim full = new(0, Capacity);         // 满位信号量
    private static readonly Lock locker = new();                 // 替换 object 的 Lock 类型
    
    static void Main() {
        new Thread(Producer).Start();
        new Thread(Consumer).Start();
    }
    
    static void Producer() {
        for (int i = 0; i < 10; i++) {
            empty.Wait(); // 申请空位，无空位则阻塞
            
            using (locker.EnterWriteLock()) // 生产操作（写），获取写锁
            {
                buffer.Enqueue(i);
                Console.WriteLine($"生产: {i}");
            }
            
            full.Release(); // 释放满位信号量（增加一个满位）
            Thread.Sleep(200);
        }
    }
    
    static void Consumer() {
        for (int i = 0; i < 10; i++) {
            full.Wait(); // 申请满位，无数据则阻塞
            
            using (locker.EnterReadLock()) // 消费操作（读），获取读锁（更高效）
            {
                var item = buffer.Dequeue();
                Console.WriteLine($"消费: {item}");
            }
            
            empty.Release(); // 释放空位信号量（增加一个空位）
            Thread.Sleep(300);
        }
    }
}
```

## 关键概念

### 1. 信号量(SemaphoreSlim)
- `empty`信号量：表示缓冲区中的空位数量，初始值为缓冲区容量
- `full`信号量：表示缓冲区中的数据数量，初始值为0

### 2. 读写锁
- 使用.NET最新的`Lock`类型（锁对象）替代原来的的`lock`语句
- 生产者获取写锁(`EnterWriteLock`)进行生产操作
- 消费者获取读锁(`EnterReadLock`)进行消费操作

### 3. 缓冲区
- 使用`Queue<int>`作为缓冲区
- 容量固定为5(`Capacity = 5`)

## 实现要点

1. **生产者流程**:
   - 等待空位信号量(`empty.Wait()`)
   - 获取写锁进行生产操作
   - 释放满位信号量(`full.Release()`)
   - 适当休眠模拟生产耗时

2. **消费者流程**:
   - 等待满位信号量(`full.Wait()`)
   - 获取读锁进行消费操作
   - 释放空位信号量(`empty.Release()`)
   - 适当休眠模拟消费耗时

3. **同步机制**:
   - 信号量控制生产消费节奏
   - 读写锁保证缓冲区操作的线程安全
   - 使用`using`语句确保锁的正确释放

## 总结
这种实现方式相比传统的`lock`语句有以下优势：
1. 读写锁分离提高了并发性能
2. 信号量精确控制缓冲区状态
3. 代码结构清晰，易于理解和维护
